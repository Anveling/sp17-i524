\documentclass[9pt,twocolumn,twoside]{styles/osajnl}
\usepackage{fancyvrb}
\journal{i524} 

\title{REEF}

\author{Pratik Jain}
\affil{School of Informatics and Computing, Bloomington, IN 47408, U.S.A.}
\affil{Corresponding authors: jainps@iu.edu}

\dates{Paper-2, \today}

\ociscodes{REEF, Tang, Wake}

% replace this with your url in github/gitlab
\doi{\url{https://github.com/pratik11jain/sp17-i524/blob/master/paper2/S17-IR-2012/report.pdf}}


\begin{abstract}
Apache REEF is a Big Data system that makes it easy to implement scalable, fault-tolerant runtime environments for a range of data processing models on top of resource managers such as Apache YARN and Mesos. The key features and abstractions of REEF are discussed. Two libraries of independent value are introduced. Wake is an event-based-programming framework and Tang is a dependency injection framework designed specifically for configuring distributed systems. \newline
\end{abstract}

\setboolean{displaycopyright}{true}

\begin{document}

\maketitle

\section{Introduction}

With the continuous growth of Hadoop the range of computational primitives expected by its users has also broadened. A number of performance and workload studies have shown that Hadoop MapReduce is a poor fit for iterative computations, such as machine learning and graph processing. Also, for extremely small computations like ad-hoc queries that compose the vast majority of jobs on production clusters, Hadoop MapReduce is not a good fit. Hadoop 2 addresses this problem by factoring MapReduce into two components: an application master that schedules computations for  a  single job  at a  time,  and YARN,  a cluster resource manager that coordinates between multiple jobs  and tenants. In spite of the fact that this resource manager, YARN,  allows a  wide range  of computational frameworks to  coexist in  one cluster, many challenges  remain \cite{reefpaper}. Apache REEF (Retainable Evaluator Execution Framework), a library for developing portable applications for cluster resource managers such as Apache Hadoop YARN or Apache Mesos, addresses these challenges.

\section{Features}

Due to the following critical features, Apache REEF drastically simplifies development of resource managers \cite{reefhome}.

\subsection{Centralized Control Flow} 
Apache REEF turns the chaos of a distributed application into various events in a single machine. These events include container allocation, Task launch, completion, and failure.
\subsection{Task runtime}
Apache REEF provides a Task runtime which is instantiated in every container of a REEF application and can keep data in memory in between Tasks. This enables efficient pipelines on REEF.
\subsection{Support for multiple resource managers}
Apache REEF applications are portable to any supported resource manager with minimal effort. In addition to this, new resource managers are easy to support in REEF.
\subsection{.NET and Java API}
Apache REEF is the only API to write YARN or Mesos applications in .NET. Additionally, a single REEF application is free to mix and match tasks written for .NET or Java.
\subsection{Plugins} 
Apache REEF allows for plugins to augment its feature set without hindering the core. REEF includes many plugins, such as a name-based communications between Tasks, MPI-inspired group communications, and data ingress. \newline

As a result of such features Apache REEF shows properties like retainability of hardware resources across tasks and  jobs, composability of operators  written for  multiple computational frameworks and storage backends, cost modeling for data movement and single machine parallelism, fault handling \cite{techopedia} and elasticity.

\section{Key Abstractions}

REEF is structured around the following key abstractions \cite{reefarticle}:

Driver: This is a user-supplied control logic that implements the resource allocation and Task scheduling logic. There is exactly one Driver for each Job. The duration and characteristics of the Job are determined by this module.

Task: This encapsulates the task-level client code to be executed in an Evaluator.

Evaluator: This is a runtime environment on a container that can retain state within Contexts and execute Tasks (one at a time). A single evaluator may run many activities throughout its lifetime. This enables sharing among Activities and reduces scheduling costs.

Context: It is a state management environment within an Evaluator that is accessible to any Task hosted on that Evaluator.

Services: Objects and  daemon threads that are retained across Tasks that run within an Evaluator \cite{reefpaper}. Examples include caches of parsed data, intermediate state, and network connection pools.


\section{Wake and Tang}

The lower levels of REEF can be decoupled from the data models and semantics of systems built atop it. This results in two standalone systems, Tang and Wake which are both language independent and allow REEF to bridge the JVM and .NET.\newline

Tang is a configuration management and checking framework \cite{reeftang}. It emphasizes explicit documentation and automatic checkability of configurations and applications instead of ad-hoc, application-specific configuration and bootstrapping logic. It not only supports distributed, multi-language applications but also gracefully handles simpler use cases. It makes use of dependency injection to automatically instantiate applications. Given a request for some type of object, and information that explains how dependencies between objects should be resolved, dependency injectors automatically instantiate the requested object and all of the objects it depends upon. Tang makes use of a few simple wire formats to support remote and even cross-language dependency injection.\newline

Wake is an event-driven framework based on ideas from SEDA, Click, Akka and Rx \cite{reefwake}. It is general purpose in the sense that it is designed to support computationally intensive applications as well as high-performance networking, storage, and legacy I/O systems. Wake is implemented to support high-performance, scalable analytical processing systems i.e. big data applications. It can be used to achieve high fanout and low latency as well as high-throughput processing and it can thus aid to implement control plane logic and the data plane.

% Bibliography

\bibliography{references}

\end{document}
